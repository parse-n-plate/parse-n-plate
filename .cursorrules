# Cursor AI Rules for Parse N' Plate

## üìã Changelog Maintenance

### When to Update CHANGELOG.md
Automatically remind the user to update the CHANGELOG.md when making:

1. **Major Changes** (use üõë HIGH RISK MODIFICATION signal):
   - Breaking changes to APIs or components
   - Removing or deprecating features
   - Major refactoring that affects multiple files
   - Changes to core functionality

2. **Significant Features** (use ‚ö†Ô∏è LARGE CHANGE ALERT signal):
   - New pages or routes
   - New API endpoints
   - New components with significant functionality
   - Integration of new third-party services
   - Database schema changes
   - Major UI/UX improvements

3. **Important Updates**:
   - Bug fixes that affect user experience
   - Security updates
   - Performance improvements
   - Dependency updates (major versions only)
   - Configuration changes

### Reminder Format
When making changes that should be logged, include a reminder like:

```
üìã CHANGELOG REMINDER:
Please update CHANGELOG.md under the [Unreleased] section with:
- Category: [Added/Changed/Fixed/etc.]
- Description: [Brief description of what changed]
```

### Don't Update for:
- Minor code formatting or style changes
- Comment updates
- README updates (unless they reflect feature changes)
- Test file additions
- Minor dependency patch updates
- Internal refactoring that doesn't change functionality

---

## üë§ User Context

### User Profile
- Product designer with limited coding experience
- Prefers detailed explanations over brief technical answers
- Learning-focused approach to development

### Communication Preferences
- Use smaller, incremental changes
- Provide educational context and explanations
- Break down complex concepts into simple steps
- Explain reasoning behind decisions
- Use clear visual signals: ‚ö†Ô∏è üõë ‚è∏Ô∏è üìã ‚úÖ

### Code Changes
- Make incremental changes, not large modifications
- Add detailed comments explaining what and why
- For large/risky changes:
  - Use "‚ö†Ô∏è LARGE CHANGE ALERT" or "üõë HIGH RISK MODIFICATION"
  - Provide specific warnings
  - Wait for user confirmation before implementing
- Always explain each step of code changes

---

## üèóÔ∏è Project Architecture

### Tech Stack
- **Frontend**: Next.js 15, React 19, TypeScript
- **Styling**: Tailwind CSS 4, shadcn/ui components
- **Backend**: Next.js API routes, Python (recipe-scrapers)
- **AI**: Groq API (Llama models), OpenAI SDK
- **Storage**: localStorage (client-side)

### Key Patterns
- Context API for state management (RecipeContext, ParsedRecipesContext)
- API routes in `/app/api/` for backend logic
- Custom hooks in `/hooks/` for reusable logic
- UI components in `/components/ui/` (shadcn/ui)
- Utility functions in `/utils/` and `/lib/`

---

## üé® UI Component Guidelines

### Global CSS Updates
**ALWAYS update `src/app/globals.css` when creating or updating UI components.**

When working with UI components in `/components/ui/`:

1. **New Components**:
   - Check if the component needs custom CSS variables, utility classes, or component-specific styles
   - Add any necessary styles to `globals.css` in the appropriate layer:
     - `@layer base` - Base element styles
     - `@layer components` - Component-specific styles
     - `@layer utilities` - Utility classes

2. **Updating Components**:
   - Review if style changes require updates to `globals.css`
   - Add new CSS variables if introducing new design tokens
   - Add component-specific classes if needed
   - Update existing styles if component behavior changes

3. **What to Add to globals.css**:
   - Custom CSS variables for colors, spacing, typography
   - Component-specific utility classes
   - Shared component styles (e.g., `.control-card`, `.servings-controls-container`)
   - Design system tokens that multiple components might use

4. **Organization**:
   - Follow the existing structure: CSS variables in `:root`, base styles in `@layer base`, utilities in `@layer utilities`, components in `@layer components`
   - Add comments to group related styles
   - Keep styles organized by purpose (typography, colors, spacing, components)

**Default Behavior**: When creating or modifying any file in `/components/ui/`, automatically check and update `src/app/globals.css` if needed, even if the user doesn't explicitly request it.

---

## üéØ Code Quality Standards

### TypeScript
- Always use explicit types
- Avoid `any` type when possible
- Define interfaces for complex objects

### React Best Practices
- Use functional components with hooks
- Implement proper error boundaries
- Use loading states for async operations
- Keep components focused and single-purpose

### Comments
- Add explanatory comments for complex logic
- Document function purposes and parameters
- Include TODO comments for future improvements

### Error Handling
- Provide user-friendly error messages
- Log errors appropriately
- Use try-catch blocks for async operations

---

## üìù Documentation

### When to Update Docs
- New features require README updates
- API changes need documentation
- Complex features need explanation
- Setup steps change

### Documentation Files
- `README.md` - Main project documentation
- `CHANGELOG.md` - Version history
- `TECHNICAL_SUMMARY.md` - Technical overview
- `MIGRATION_QUICK_REFERENCE.md` - Migration guides
- `ENVIRONMENT_SETUP.md` - Setup instructions
- `FONT_SETUP.md` - Typography guide

---

## üîÑ Workflow Reminders

1. **Before Large Changes**:
   - Show warning signal (‚ö†Ô∏è or üõë)
   - Explain what will change and why
   - Wait for user confirmation

2. **After Implementing Changes**:
   - Remind about changelog if applicable
   - Suggest testing steps
   - Explain what was changed in detail

3. **For New Features**:
   - Add TypeScript types
   - Add error handling
   - Include loading states
   - Update relevant documentation
   - Add to changelog

---

## üîÄ Git Workflow Reminders

### When to Remind About Git Push
After completing significant work sessions or implementing features, remind the user to push their changes to the remote repository.

### Reminder Triggers
Remind the user to push when:
1. **After Completing Features**:
   - New functionality has been implemented and tested
   - Multiple files have been modified
   - A logical unit of work is complete

2. **After Fixing Issues**:
   - Bug fixes are complete
   - Error handling improvements
   - Performance optimizations

3. **End of Work Session**:
   - When wrapping up a coding session
   - Before switching to a different task
   - When there are uncommitted changes that should be saved

4. **Before Making Large Changes**:
   - If there are uncommitted changes before starting major refactoring
   - Before switching branches (if applicable)

### Reminder Format
When appropriate, include a reminder like:

```
üîÄ GIT PUSH REMINDER:
You have uncommitted changes. Consider pushing to remote:
1. Review your changes: git status
2. Stage changes: git add .
3. Commit: git commit -m "Description of changes"
4. Push: git push origin [branch-name]
```

### Don't Remind For:
- Very minor changes (single character fixes, typos)
- Work in progress that's clearly not ready
- When user explicitly says they're not ready to commit
- During active debugging sessions

### Git Best Practices to Encourage
- Commit frequently with clear, descriptive messages
- Push regularly to avoid losing work
- Keep commits focused on a single feature or fix
- Use meaningful commit messages that explain what and why

---

## üöÄ Development Commands

```bash
npm run dev          # Start development server
npm run build        # Build for production
npm run lint         # Run ESLint
npm run lint:fix     # Fix ESLint issues
npm run docker:build # Build Docker image
npm run docker:run   # Run Docker container
```

